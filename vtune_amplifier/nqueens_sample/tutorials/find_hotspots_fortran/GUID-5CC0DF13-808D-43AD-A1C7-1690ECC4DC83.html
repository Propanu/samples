<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0014)about:internet -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="DC.Type" content="topic" />
<meta name="DC.Title" content="Summary" />
<meta name="DC.Relation" scheme="URI" content="GUID-31A20E55-3123-4706-B320-131A8C7D4416.html" />
<meta name="prodname" content="VTune Amplifier" />
<meta name="version" content="2016" />
<meta name="series" content="" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="GUID-5CC0DF13-808D-43AD-A1C7-1690ECC4DC83" />
<meta name="DC.Language" content="en-US" />
<link rel="stylesheet" type="text/css" href="intel_css_styles.css" />
<title>Summary</title>
<script src="resources/prism/prism.js"><!----></script>
<link href="resources/prism/prism.css" rel="stylesheet" />
</head>
<body id="GUID-5CC0DF13-808D-43AD-A1C7-1690ECC4DC83">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; VTune&#8482; Amplifier</em></p>


<h1 class="topictitle1">Summary</h1>
<div><p><img id="IMAGE_0FB23154C9754CB790C6670532DC019E" src="GUID-02914B5D-1A7D-4B4B-8A24-9534BDA714E4-low.gif" /> You have completed the Finding Hotspots tutorial. Here are some
		important things to remember when using the 
		<span>Intel&reg; VTune&#8482; Amplifier</span>
		to analyze your code for hotspots: 
	 </p>

<div class="tablenoborder"><table cellpadding="4" summary="" id="GUID-A2574C73-F273-4522-8CF5-1AA0A73BB88E" frame="border" border="1" cellspacing="0" rules="all"><thead align="left"><tr><th class="cellrowborder" valign="top" width="21.008403361344538%" id="d1935e33"><p>Step 
				  </p>
</th>
<th class="cellrowborder" valign="top" width="30.672268907563026%" id="d1935e36"><p>Tutorial Recap 
				  </p>
</th>
<th class="cellrowborder" valign="top" width="48.319327731092436%" id="d1935e39"><p>Key Tutorial Take-Aways 
				  </p>
</th>
</tr>
</thead>
<tbody><tr><td class="cellrowborder" valign="top" width="21.008403361344538%" headers="d1935e33 "><p><strong>1. Prepare for analysis</strong></p>
</td>
<td class="cellrowborder" valign="top" width="30.672268907563026%" headers="d1935e36 "><p> 
					 You set up your environment to enable generating symbol
					 information for your binary files, built the target, created the
					 performance baseline, and created the VTune Amplifier project for your analysis
					 target. 
				  </p>
</td>
<td class="cellrowborder" valign="top" width="48.319327731092436%" headers="d1935e39 "><ul id="GUID-66B33661-6B81-4091-A48D-05B94130D49C"><li id="LI_97D3A49944A2476CA7564F3F09E1A3A3"><p>Configure your project properties to get the most accurate
						  results for user binaries and to analyze the performance of your application at
						  the code line level. 
						</p>
</li>
<li id="LI_B7648574518441CD881881A2CAFBC559"><p>Create a performance baseline to compare the application
						  versions before and after optimization. Make sure to use the same workload for
						  each application run. 
						</p>
</li>
<li id="LI_320257E7CE2149D1B86F5948AB7D38A5"><p> Use the 
						  <strong>New Amplifier Result</strong> tab to choose and configure
						  your analysis target. 
						  </p>
</li>
<li id="LI_2975AA44D665489E8ACCBD16B86CCD8D"><p>Use the 
						  <strong>Analysis Type</strong> configuration window to choose,
						  configure, and run the analysis. You can also run the analysis from command
						  line using the 
						  <samp class="codeph">amplxe-cl 
						  </samp>command. 
						</p>
</li>
</ul>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="21.008403361344538%" headers="d1935e33 "><p><strong>2. Find hotspots</strong></p>
</td>
<td class="cellrowborder" valign="top" width="30.672268907563026%" headers="d1935e36 "><p>You launched the Basic Hotspots data collection that analyzed
					 function calls and CPU time spent in each program unit of your application and
					 identified the following hotspots: 
				  </p>
<p><ul id="GUID-582D5247-6293-4D1C-8319-6EA24B212F2D"><li id="LI_079F909DBEDE44A8A8C7297E78E53879">A function that
						took the most CPU time and could be a good candidate for algorithm tuning. 
					 </li>
<li id="LI_B4CBDB2B2E72491D94D0BF651DCAA088">The code section
						that took the most CPU time to execute. 
					 </li>
</ul>
</p>
</td>
<td class="cellrowborder" valign="top" width="48.319327731092436%" headers="d1935e39 "><ul id="GUID-0591BC70-9B13-4D30-ACA3-AD8F7874F9F7"><li id="LI_B0C280DA3E434E5782974EEB7BE3B27C"><p>Start analyzing the performance of your application from
						  the 
						  <strong>Summary</strong> window to explore the performance metrics
						  for the whole application. Then, move to the 
						  <strong>Bottom-up</strong> window to analyze the performance per
						  function. Focus on the 
						  <em>hotspots</em> - functions that took the most CPU time. By
						  default, they are located at the top of the table. 
						</p>
</li>
<li id="LI_F2D57AF2CDD74FC190B0EF96044F8224"><p>Double-click the hotspot function in the 
						  <strong>Bottom-up</strong> pane or 
						  <strong>Call Stack</strong> pane to open its source code and navigate
						  between hotspots using the 
						  <strong>Source</strong> window navigation buttons. 
						</p>
</li>
</ul>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="21.008403361344538%" headers="d1935e33 "><p><strong>3. Eliminate hotspots</strong></p>
</td>
<td class="cellrowborder" valign="top" width="30.672268907563026%" headers="d1935e36 "><p>You optimized the algorithm by enabling the OpenMP* library
					 create a private copy of the array. You rebuilt the application and got
					 performance gain of 
					 <span>200144</span> ms. 
				  </p>
</td>
<td class="cellrowborder" valign="top" width="48.319327731092436%" headers="d1935e39 "><p>Click the 
					 <img id="IMAGE_67209CB6FB3E4248877B1FF48328D78A" src="GUID-66F5A54E-83EC-4E60-AD9A-83481F49715D-low.jpg" /><strong>Source Editor</strong> button to open your default source editor
					 directly from the VTune Amplifier 
					 <strong>Source</strong> window. 
				  </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="21.008403361344538%" headers="d1935e33 "><p><strong>4. Analyze concurrency</strong></p>
</td>
<td class="cellrowborder" valign="top" width="30.672268907563026%" headers="d1935e36 "><p>You launched the Concurrency analysis and identified poor
					 thread concurrency for the whole application execution. You analyzed the
					 timeline and identified poor thread balance: all OpenMP threads were constantly
					 transferring execution to each other and were waiting for all threads to
					 complete execution. 
				  </p>
</td>
<td class="cellrowborder" valign="top" width="48.319327731092436%" headers="d1935e39 "><ul id="GUID-7DA7582B-7323-427E-A14B-53CE4BA2E96F"><li id="LI_7F1590A6B5724C239023ADE0D218F35A"><p>Start your analysis with the 
						  <strong>Summary</strong> window. Consider the 
						  <strong>Target</strong> concurrency metric specified in the 
						  <strong>CPU Usage Histogram</strong> as your optimization goal. The 
						  <strong>Average</strong> metric is calculated as CPU time / Elapsed
						  time. Use this number as another baseline for your performance measurements.
						  The closer this number to the number of cores, the better. 
						</p>
</li>
<li id="LI_70E73B930CEC490BB55941051B07825C"><p>In the 
						  <strong>Bottom-up</strong> window, use the 
						  <strong>Filter In by Selection</strong> context menu option to focus
						  on the performance-critical functions in the grid and analyze their performance
						  over time in the 
						  <strong>Timeline</strong> pane. 
						</p>
</li>
</ul>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="21.008403361344538%" headers="d1935e33 "><p><strong>5. Find lock</strong></p>
</td>
<td class="cellrowborder" valign="top" width="30.672268907563026%" headers="d1935e36 "><p>You ran the Locks and Waits analysis and identified two
					 synchronization objects with the high Wait Time and Wait Count values and poor
					 CPU utilization that could be locks affecting application parallelism. Your
					 next step is to analyze the code of their wait functions. 
				  </p>
</td>
<td class="cellrowborder" valign="top" width="48.319327731092436%" headers="d1935e39 "><ul id="GUID-F15997E0-21A8-4C9B-A943-F131338DE39C"><li id="LI_611A778A0E7F44B387069AD6B1CE5DF2"><p>Use the 
						  <strong>Analysis Type</strong> configuration window to choose,
						  configure, and run the analysis. For recently used analysis types, you may use
						  the shortcuts to run a recent analysis: 
						<ul id="GUID-D943B24A-C852-4FEB-AB23-40DF962B8A15"><li id="LI_9DC6D9EA656F4F0EA86014B805BBB7EB"><p>From the 
								<strong>File</strong> menu, select 
								<strong>New &gt; [recent_analysis_type]</strong>. 
							 </p>
</li>
</ul>
</p>
</li>
<li id="LI_207AD58287384F77B1F85ADF35F2FA6A">In the 
						<strong>Bottom-up</strong> window, focus on the synchronization objects
						that under- or over-utilized the available logical CPUs and have the highest
						Wait time and Wait Count values. By default, the objects with the highest Wait
						time values show up at the top of the window. 
					 </li>
</ul>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="21.008403361344538%" headers="d1935e33 "><p><strong>6. Remove lock</strong></p>
</td>
<td class="cellrowborder" valign="top" width="30.672268907563026%" headers="d1935e36 "><p>You optimized the application execution time by removing the
					 unnecessary critical section that caused redundant synchronization 
					 . 
				  </p>
</td>
<td class="cellrowborder" valign="top" width="48.319327731092436%" headers="d1935e39 "><p>Double-click the most time-critical synchronization object in
					 the 
					 <strong>Bottom-up</strong> pane. This opens the source code for the wait
					 function it belongs to. Use the hotspot navigation buttons to identify the most
					 time-critical code lines. 
				  </p>
</td>
</tr>
<tr><td class="cellrowborder" valign="top" width="21.008403361344538%" headers="d1935e33 "><p><strong>7. Check your work</strong></p>
</td>
<td class="cellrowborder" valign="top" width="30.672268907563026%" headers="d1935e36 "><p>You ran the Locks and Waits analysis on the optimized code and
					 compared the results before and after optimization using the Compare mode of
					 VTune Amplifier. 
				  </p>
</td>
<td class="cellrowborder" valign="top" width="48.319327731092436%" headers="d1935e39 "><p>Perform regular regression testing by comparing analysis
					 results before and after optimization. Click the 
					 <img id="IMAGE_0730E0400248497282DB927E654FDEA2" src="GUID-E632A67E-51CD-4676-B252-0F411DF5A068-low.gif" /><strong>Compare Results</strong> button on the VTune Amplifier toolbar.
					 From command line, use the 
					 <samp class="codeph">amplxe-cl</samp> command. 
				  </p>
</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Next step:</strong> Prepare your own application(s) for analysis. Then use
		the VTune Amplifier to find and eliminate hotspots. 
	 </p>
</div>

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-31A20E55-3123-4706-B320-131A8C7D4416.html">Tutorial: Finding Hotspots - Fortran Sample Code</a></div>
</div>
<div></div>
</body>
</html>
